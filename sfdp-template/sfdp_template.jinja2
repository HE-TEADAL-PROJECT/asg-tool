from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse
import traceback
from pydantic_settings import BaseSettings

from gin.executor import exec

class Settings(BaseSettings):
    debug: bool = False

settings = Settings()

app = FastAPI()

def log_level_string():
    if settings.debug:
        return "DEBUG"
    else:
        return None

@app.get("/info")
async def info():
    return {
        "debug": settings.debug,
    }

# Define FastAPI endpoints
{% for endpoint in endpoints %}
@app.{{ endpoint.method }}("{{ endpoint.sfdp_endpoint_path }}")
async def {{ endpoint.sfdp_endpoint_name }}({% for param in endpoint.parameters %}{{ param.name }}: {% if param.type == 'string' %}str{% elif param.type == 'integer' %}int{% elif param.type == 'boolean' %}bool{% elif param.type == 'number' %}float{% else %}Any{% endif %}{% if param.nullable %} = None{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}):
    """
    {{ endpoint.description }}
    """
    path_params = {
        {%- for param in endpoint.parameters if param.in == 'path' %}
        "{{ param.name }}": {{ param.name }}{%- if not loop.last %},{%- endif %}
        {%- endfor %}
    }
    query_params = {
        {%- for param in endpoint.parameters if param.in == 'query' %}
        "{{ param.name }}": {{ param.name }}{%- if not loop.last %},{%- endif %}
        {%- endfor %}
    }
    # Create Yaml and run executor
    full_spec = {{endpoints_full_connectors_specs[endpoint.sfdp_endpoint_name]}}
    for i, param in enumerate(path_params):
        if full_spec["spec"]["apiCalls"]["{{endpoint.name}}"]["arguments"][i]["argLocation"] == 'parameter':
            full_spec["spec"]["apiCalls"]["{{endpoint.name}}"]["arguments"][i]["value"] = path_params[param]

    for i, param in enumerate(query_params):
        if full_spec["spec"]["apiCalls"]["{{endpoint.name}}"]["arguments"][i]["argLocation"] == 'header':
            full_spec["spec"]["apiCalls"]["{{endpoint.name}}"]["arguments"][i]["value"] = query_params[param] 

    spec_string = f"""{full_spec}"""

    try:
        res = exec.run_from_spec_string(
            spec_string, 
            log_level=log_level_string(),
            user_functions_path="./transform")
    except FileNotFoundError as e:
        raise HTTPException(status_code=404, detail="The specified file or directory was not found.")
    except PermissionError as e:
        raise HTTPException(status_code=403, detail="Permission denied. Ensure you have the necessary access rights.")
    except SyntaxError as e:
        raise HTTPException(status_code=400, detail=f"Syntax error in the provided spec file: {str(e)}")
    except Exception as e:
        error_message = f"Executor failed to run the spec file: {str(e)}"
        traceback.print_exc()  # Logs the full traceback for debugging
        raise HTTPException(status_code=500, detail=error_message)
    
    try:
        response_data = {key: (df.dropna()).to_dict(orient='records') for key, df in res.items()}
    except:
        # In case no transformations, return json.
        return JSONResponse(res['.'])
    return JSONResponse(response_data)
{% endfor %}
