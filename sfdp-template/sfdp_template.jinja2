from typing import Any
import logging
from contextlib import asynccontextmanager

from fastapi import FastAPI, HTTPException, Request, Response
from starlette.status import HTTP_200_OK

from asg_runtime import Executor


@asynccontextmanager
async def lifespan(app: FastAPI):
    try:
        executor = await Executor.async_create()
        app.state.executor = executor
        app.state.settings = executor.get_settings()

        yield  # reached if no errors
    except Exception:
        # log and exit on startup error
        import traceback
        print(traceback.format_exc())
        raise

    # clean things up if needed
    await executor.shutdown()


app = FastAPI(lifespan=lifespan)
logger = logging.getLogger(__name__)

# --- Service Endpoints ---

@app.get("/service/settings", tags=["service"])
def get_settings(request: Request) -> dict:
    return request.app.state.settings


@app.get("/service/stats", tags=["service"])
async def get_stats(request: Request) -> dict:
    executor: Executor = request.app.state.executor
    return executor.get_stats()

@app.get("/service/transforms", tags=["service"])
async def get_transforms(request: Request) -> list:
   executor: Executor = request.app.state.executor
   return executor.get_transforms()
   
@app.post("/service/origin_cache/clean", tags=["service"])
async def clear_origin_cache(request: Request) -> str:
    executor: Executor = request.app.state.executor
    result = await executor.async_clear_origin_cache()
    return result


@app.post("/service/response_cache/clean", tags=["service"])
async def clear_response_cache(request: Request) -> str:
    executor: Executor = request.app.state.executor
    result = await executor.async_clear_response_cache()
    return result


# --- Data Endpoints ---
# helper called by all data endpoints
async def get_endpoint_data(request: Request, endpoint_spec: str) -> Response:
    executor: Executor = request.app.state.executor
    try:
        result = await executor.async_get_endpoint_data(endpoint_spec)

        if result.get("status") == "ok":
            return Response(
                content=result["data"], 
                media_type="application/json",
                status_code=HTTP_200_OK)
        
        # "status" is is not "ok" - return error
        raise HTTPException(status_code=500, detail=result.get("message", "Unknown error"))

    except HTTPException:
        raise
    except Exception as e:  
        # unhandled exception - log and return error
        import traceback
        print(traceback.format_exc())
        message = f"Unhandled exception of type {type(e)} in get_endpoint_data: {e}."
        raise HTTPException(status_code=500, detail=message)
 
# --- Generated Data Endpoints ---

{% for ep in endpoints %}
@app.{{ ep.http_method }}("{{ ep.sfdp_ep_path }}", tags=["data"])
async def {{ ep.sfdp_ep_name }}(request: Request, {% for param in ep.sfdp_ep_params %}{{ param.name }}: {{ param.py_type }}{% if param.nullable %} = None{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}):

    """
    SFDP endpoint description: {{ ep.sfdp_ep_descr }}

    source
    FDP endpoint description: {{ ep.fdp_ep_descr }}
    FDP endpoint summary: {{ ep.fdp_ep_sum }}
    """

    endpoint_spec: dict[str, Any] = {{ ep.spec | render_spec }}

    {% if ep.fdp_ep_p_params or ep.fdp_ep_q_params %}
    fdp_path_params: dict = {
    {%- for name, symbol in ep.fdp_ep_p_params.items() %}
        "{{ name }}": {{ symbol }}{{ "," if not loop.last }}
    {%- endfor %}
    }
    fdp_query_params: dict = {
    {%- for name, symbol in ep.fdp_ep_q_params.items() %}
        "{{ name }}": {{ symbol }}{{ "," if not loop.last }}
    {%- endfor %}
    }
    fdp_args = endpoint_spec["spec"]["apiCalls"]["{{ep.fdp_ep_name}}"]["arguments"]
    for fdp_arg in fdp_args:
        arg_name=fdp_arg["name"] 
        logger.debug(f"fdp_arg={fdp_arg}")
        if fdp_arg["argLocation"] == 'parameter':
            value = fdp_path_params.get(arg_name)
            logger.debug(f"path parameter with value {value}")
        elif fdp_arg["argLocation"] == 'header':
            value = fdp_query_params.get(arg_name)
            logger.debug(f"query parameter with value {value}")
        else:
            logger.warning(f"unsupported fdp argument argLocation: {fdp_arg["argLocation"]}")
            continue
        if not value:
            logger.warning(f"failed to match fdp argument: {arg_name}")
            continue
        logger.debug(f"substituting fdp parameter {arg_name} with value={value}")
        fdp_arg["value"] = value 
    {% endif %}

    spec_string = f"""{endpoint_spec}"""
    return await get_endpoint_data(request, spec_string)

{% endfor %}
